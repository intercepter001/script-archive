#!/usr/bin/perl

# Grep.pm helper to non-interactively edit files according 
# to (filtered/edited) grep output, creating a patchfile
# as undo log. The idea is having something like emv, but
# not for mass-renaming files, but for changing file contents:
# Grep.pm ... | pipe.vim | Grep.xchange ...
# 
# featuring a little improbility: perl -i.bak interactive one-liner,
# and a small impossibility: a perl variable-length zero-width lookbehind regex.

# 08.08.09 PJ        jakobi@acm.org -- initial version
# 13.08.09 PJ  0.1   added diff -u style undo log to allow undo by patch, -flock, -p
# copyright:  (c) 2009 jakobi@acm.org, placed under GPL v3 or later 
my $version="0.1";  

use strict;
use vars;
use warnings;


# one use of flockFH() if -(f)lock is requested
#do "Flock.pm";
BEGIN{
   do{my $p=$0; $0=~s@[^/]*$@@; unshift @INC, $p};
   unshift @INC,  "$ENV{HOME}/bin", "$ENV{HOME}/bin/perl",  "$ENV{HOME}/bin/perl/Compact_pm"; 
}
use Flock; # Compact_pm::Flock


# Alternatives: 
# - vim SedS, or 
#       .-command and vimgrep, 
#       :args *.c and :argdo g/RE/p s//S/c
# - extend my ancient non-interactive mass-file string/regex-replacer 
#   xchange.pl with a  zap-style interaction from myrename
#   plus a show context command. But the same issues as with the oneliner 
#   example below still apply.
# - perl -i.bak (without interaction)


# Interactive perl -i.bask one-liners:
#
#   perl wouldn't be perl if it couldn't add the interaction 
#   within the limits of a one-liner:
#
# - tested interactive perl -i.bak example requiring the keypress 'y' 
#   (without <CR>) to modify a compact line into line too-large.
#   As perl always creates the backup, even for non-changed files,
#   better filter the filelist first. If you really HAVE to press ^c,
#   enter stty sane^j. Still, Grep.xchange is 'safer' as the filtering
#   decision is removing or keeping grep results in an editor with 
#   unlimited undo, while the interactive perl example commits a change
#   on a sole undoable keypress with little context.
if (0){q!
# command $(ls -1d) is pretty unsafe when there may
# be file names with blanks and worse. Thus first make a
# shell array contain the files of interest. If you have 
# the f2a shell function, this simplifies to just
# grep -l -i compact *.c | f2a -a A (note that -i breaks
# hardlinks and replaces symlinks by plain files)
unset A i;typeset -a A;typeset -i i; 
while read l;do A[i]="$l";i=i+1;done < <(grep -l -i compact *.c)
# perl -i.bak line based example
perl -i.bak -ne 'BEGIN{system "stty cbreak";$|=1;warn "press y to run s///";};END{system "stty sane"}; 
                 print main::STDERR "\n# FILE $ARGV\n" if $f ne $ARGV; $f=$ARGV;
                 if(/compact/){ chomp($t=$_); 
                    print main::STDERR "$t ? "; read(STDIN,$ans,1); print main::STDERR "\n"; 
                    s/compact/too-large/g if $ans eq "y"
                 }; print' "${A[@]}"
# and slurp mode example (.*?STRING.* triggers only once per line)
perl -i.bak -pe 'BEGIN{system "stty cbreak";$|=1;undef $/;warn "press y to run s///";};END{system "stty sane"};
                 print main::STDERR "\n# FILE $ARGV\n";
                 s{(.*?)(compact)(.*)}{do{ chomp($t=$out=$&); 
                    print main::STDERR "$t ? "; read(STDIN,$ans,1); print main::STDERR "\n"; 
                    $out="$1too-large$3" if $ans eq "y"; 
                    $out}}geo;
                 ' "${A[@]}"
!}
#  grep -l -i compact *.c | while read l;do a[i]="$l";i=i+1;done # ksh 



my $backposmax=200;                            # -bpmax default for var length zero width look behind
my $bufferlines=2;                             # number of lines to provide in buffer
my $diffcmd="diff";                            # --diff command
my $o_follow=1;                                # resolve symlinks?
my $o_preserve_hardlink=0;                     # preserve hardlinks?
my $verbose;                                   # --verbose
my ($o_diff,$o_context,$o_flock);
my $fileh="";                                  # filehandle for locking


# undo log setup
my $o_log=1;                                   # create diffs?
my $logcmd="diff -u";
my @time=localtime(time);
my $logtime=sprintf "%4d%02d%02d%02d%02d%02d", 1900+$time[5],1+$time[4],$time[3],@time[2,1,0];
my $logdir="/var/tmp/Grep-xchange-$ENV{LOGNAME}";  # logdir
my $logfile="$logdir/diffset.$logtime.$$";     # logfile for this session
my $logclean="diffset*";                       # pattern of too-ancient logs to remove
my $logkeep=8;                                 # days to keep

my (%files, %match);                           # hashes for the output of grep
my ($file,$filebak,$absfile,$origfile);
my ($logdata,$changedfiles,$errors,$rc);
my ($backpos,$skip,$pos,$pos0,$line,$content,$match);
my ($ERR,$LINE,$OLD,$POS,$NEW,$LINEOFFSET,$LINENO,$OLDPOS,$BUFFER); # variables explicitely provided to matchsubst


while(@ARGV) {
   $_=shift @ARGV;
   /^-C$/                      and do { $o_context=1; next};
   /^-?-verbose$|^-V$/         and do { $verbose++; next};
   /^-?-backpos$/              and do { $backpos=shift; next};
   /^-?-f?lock$/               and do { $o_flock=1; next};
   /^-?-b(ack)?p(os)?max$/     and do { $backposmax=shift; next};
   /^-?-b(uffer(lines)?)?max$/ and do { $bufferlines=shift; next};
   /^-?-diff$|^-d$/            and do { $o_diff=1; next};
   /^-?-p((reserve)?h(ard)?l(inks?)?)?$/ and do { $o_preserve_hardlink=1; next };

   /^-?-help$|^-h$/            and do { &usage; die("\n") };
   /^-?-examples$/             and do { &examples; die("\n") };
   /^--$/                      and do { last};
   /^-$/                       and do { unshift @ARGV,$_; last};
   /()/                        and do { unshift @ARGV,$_; last};
}


# compile matchsubst using the user's perlscrap
my $expr=shift;
die "no expression provided" if not $expr;
$expr='
sub matchsubst{
' . ( $backpos ?
'   if ($backpos and $pos>0) {
      $rc = /(?<=(?=[\s\S]*?((?:'.$backpos.')\G).){'.$backposmax.'})/go;
      if ($rc) {
         pos()=$pos=$pos-length($1);
      } else { 
         warn "# !   failed backposition, rejecting file ($line, $pos).\n"; 
         $ERR=2; return
      };
   }
' : '' ) . 
'   '.$expr.' ;
}';
warn "# matcher: $expr\n" if $verbose;
eval($expr);
die "$@" if $@;


# read the grep output from files or stdin
while(<>) { 
   next if not ( $o_context ? /\A(.*?):(\d+?): > (.*)/o : /\A(.*?):(\d+?):(.*)/o );
   push @{$files{$1}},$2;
   $match{"$2;$1"}=$3."\n";;
}


die "# !!! nothing to do (did you forget adding -n /dev/null to grep)" if not keys %files;


warn "\n# log $logfile*\n\n";
warn <<EOF if $version <0.2;
#########################################################
##  experimental script; diffsets are always created in
##  --> $logdir <--
##  and should be applicable to undo the changes with
##  requiring too much mangling
#########################################################

EOF


# and finally apply matchsubst to the hits in all files
file: for $file (sort keys %files) {
   close $fileh if defined $fileh;
   $LINEOFFSET=0;
   $origfile=$file;
   $file=followlink($file) if -l $file;
   my $file0; $file0=( $file eq $origfile ) ? "" : " <- $origfile";
   do{warn "# !!  not a file !? -- skipped\n"; $errors++; next file} if not -f $file;
   $absfile=$file; $absfile="$ENV{PWD}/$absfile" if $absfile!~/^\//; while($absfile=~s!/\.(?=/)|//+!/!g){;};
   warn "# F   $file$file0\n";
   $ENV{file}=$file; 
   $fileh=undef;
   open($fileh, "<", $file) or warn "!!  cannot open $file - skipping.\n" and ++$errors and next;
   if ($o_flock) {
      flockFH("exclusive", $fileh) or warn "# !!  cannot lock $file - skipping.\n" and ++$errors and next;
   }
   do{local ($/); $_=$content=<$fileh>};
   -s $file != length($_) and warn "# !!  cannot read full content of $file - skipping.\n" and ++$errors and next;

   # try to find all matches
   # paranoia: only execute the expression if we're still in sync with grep
   line: for $line (@{$files{$origfile}}) {
      $ERR=0;

      $match=$match{"$line;$origfile"};
      $line+=$LINEOFFSET;
      $skip=$line-1;

      pos=-1; pos()+=1; # ; -1 == last char; NOT 0 NOR undef
      /\A/gm; # fails and resets pattern, thus succeeding (\A and \G may not occur in the same regex)
      $pos=$pos0=pos;
      
      # keep a few earlier lines in a buffer?
      if ($bufferlines) {
         $pos=$pos0=pos;
         if ($skip>$bufferlines) {
            $skip-=$bufferlines;
            # works reliably, as $& isn't limited to the 15 or 16bit limit of parens
            if (m/(.*\n){$skip}/gm) {
               $pos=$pos0=pos;
               $skip=$bufferlines;
            } else {
               warn "# !!  lost sync even before match, refusing to continue ($line/$pos):\n#     -> $file:$line:$match";
               $errors++;
               next file;
            }
         }
      }
      
      # go to the exact position for this match
      if (($skip ? m/(.*\n){$skip}/gm : 1) and ($match eq substr($_,pos, length($match)))) {
         $pos0=0 if not defined $pos0;
         $OLDPOS=$POS=$pos=pos;
         $BUFFER=substr($_,$pos0,$pos-$pos0);
         $LINE=$match;
         $LINENO=$line;
         $OLD=$NEW=undef;

         matchsubst();

         # house keeping: bailout? update line offset if there's a
         # change in the number of \n
         if (not $ERR and $LINE ne $match) {
             pos() = $OLDPOS;
             if (not s/\G\Q$match\E/$LINE/) {
                $errors++;
                $ERR=2; warn "# !!  couldn't change content to new \$LINE, thus rejecting file ($line, $pos).\n"; 
             }
         }
         if (not defined $OLD and not defined $NEW) {
            $LINEOFFSET -= ( $match=~s/\n//g ) - ( $LINE=~s/\n//g );
         }
         if (defined $OLD and defined $NEW) { # update LINEOFFSET if requested
            $LINEOFFSET -= ( $OLD=~s/\n//g ) - ( $NEW=~s/\n//g );
         }

         # Q: $errors increment for requested errors: only ERR==2 for now
         if (1==$ERR) {
            warn "# !   matcher ends early: $file\n";
            last line;
         } elsif ($ERR) {
            warn "# !!  matcher aborts: $file ($ERR)\n";
            $errors++;
            next file;
         }

      } else {
         $pos=pos;
         warn "# !!  lost sync, refusing to continue ($line/$pos):\n#     -> $file:$line:$match";
         $errors++;
         next file;
      }
   }


   # we've done the last match for the file: do we need to report/diff/log
   if ($content eq $_) {
      warn "#     unchanged: $file\n";
      next;
   }
   $changedfiles++;
   warn "#     modified: $file\n";

   # on change: append diff -u to the log, allowing for a later patch to undo 
   #            this sessions changes; create log and logdir as necessary
   if ($o_log) { 
      # log each file's diff -u as part of a larger diff -r -u style diffset
      if (not -f $logfile) {
         &setupworkdir($logdir) or 
            die "# !!! cannot create work dir $logdir\n";
         $logfile.=".virt" if $o_diff;
         open(FH,">",$logfile) or
            die "# !!! cannot create log $logfile\n";
         print FH "## ATTENTION -- -diff used -- CHANGES DO NOT EXIST IN FILE SYSTEM\n\n" if $o_diff;
         close FH or 
            die "# !!! cannot create log\n";
      }

      $ENV{file0}="/dev/stdin"; 
      $ENV{file1}=$absfile; 
      $ENV{file2}="Grep.xchange$absfile"; 
      $ENV{logfile}=$logfile;
      $logdata ="$logcmd $ENV{file2} $ENV{file1}\n"; # FIXME Q: does patch require us to inject a fake -r here???
                                             #       Q: patch and how to add 'safe' between diff whitespace???
      open(FH,">>",$logfile) and print FH $logdata and close FH or 
         die "# !!! cannot append to log\n";
      open(FH, "| $logcmd \$file0 \$file1 >> \$logfile.tmp")
         and print FH $_ or 
         die "# !!! log: cannot execute \$logcmd\n";
      close FH or 
         do{$rc=$?>>8; die "# !!! log: error with \$logcmd: rc>10\n" if $rc>10};
      system q!perl -lpe 's@/dev/stdin@$ENV{file2}@ and $done=1 if not $done;' $logfile.tmp >> $logfile && 
               rm $logfile.tmp!;
      $rc=$?>>8 and 
         die "# !!! log: error with appending to log: $rc\n";
   }


   # on change: diff to stdout exor write back to file
   # (trying hard to NOT clobber files)
   if ($o_diff) {
      print "\n";
      if ($diffcmd!~/-/) {
         my $file0='Grep.xchange'; $file0.="/" if $file!~/^\//; $file0.=$file;
         my $time0='PresentDay PresentTime';
         my $l=length($file0); $l=length($file) if length($file) > $l;
         @time=localtime((stat($file))[9]);
         my $time=sprintf "%4d-%02d-%02d %02d:%02d:%02d", 1900+$time[5],1+$time[4],$time[3],@time[2,1,0];
         printf "<<< %-${l}s  %s\n>>> %${l}s  %s\n", $file0, $time0, $file, $time;
      }
      do{ open(FH,"| $diffcmd /dev/stdin \$file") and
          print FH $_ and
          close(FH);
      };
      print "\n";

   } else { 
      
      # write changes
      do{
         $ENV{file}=$file; $ENV{filebak}="$file.$logtime.$$.bak";
         $o_preserve_hardlink ? 
            do{ system 'cp -p $file $filebak'; not $?} : # preserve as much as our perms/id allows
            rename($file, $ENV{filebak}) 
      } and do{ 
          open(FH,">", $file) and
          print FH $_ and
          close(FH) or
          do { 
             unlink($file) and
             rename($ENV{filebak}, $file) and
             warn "# !!  error with modifying $file. Undoing rename.\n" or
             warn "# !!! serious error with $file\n";
             $errors++;
          }
      } or warn  "# !!  cannot rename or backup $file - skipping\n" and $errors++;
      warn  "\n" if $verbose;
   }
}


exit 0 if $changedfiles;
exit 2 if $errors;
exit 1; # no files changed



# -----------------------------------------------------------------------

sub usage {
   warn <<EOF

grep -n ... | pipe.vim | Grep.xchange [OPTIONS] EXPR

grep -n >         GREPOUTPUT
vi                GREPOUTPUT
Grep.xchange EXPR GREPOUTPUT

version: $version.

Use  perl  -i.bak  -ne 's///; print'  to  non-interactively  mass-edit
files.  If  however  you  want  to use  something  like  emv,  not  to
interactively   *mass-rename*   file-names,   but   to   interactively
*mass-change* file-contents in emv-style, read on:

Grep.xchange  is only suitable for the 3rd stage of this task, IFF you
wish  to  preview and modify (stage 2) the list of matches  from  grep
(stage 1). As undo-log, it also produces a patch file of all changes.

The  script  reads grep output and for each file, it slurps the  file,
then  positions  to the start of line for each match in the  file  and
executes  PERLSCRAP.  

You  can modify either the current \$LINE or the contents of the  whole
file  \$_, in which case m/\\G/g can be used to anchor to the  beginning
of the current line. Note that unanchored PERLSCRAPs like m/FOO/ match
the  first FOO anywhere after pos(), while \\G-less substitutions  like
s/FOO/BAR/  and  s/FOO/BAR/g both ignore pos(), start matching at  the
first FOO in the file and finally reset pos().

If  the file is changed, the original is renamed with a suffix \$\$.bak,
and the modified version is written to the original name.

The  script is a bit on the paranoid side and rejects modifying a file
on  the  slightest hint of trouble with  access/filetype/renaming  the
file  as  well as any problem with matching or with finding the  exact
grep  line  in  the content of the file currently being  modified.  It
entirely aborts processing in case of troubles with logging. Note that
we follow symlinks and by default break hardlinks (unless -p).

Use --examples for more information.

Options:
  -C               *marked* context mode from e.g. Grep.pm -n -C -2 
  -d               --diff -- do not write changes, but instead diffs
                   any changes to stdout. Permissions to actually 
                   modify the file are NOT tested by -d.
  -h               --help
  -p               --preserve-hardlinks
  -V               --verbose
  --backpos REGEX  non-zero width variable-length lookbehind to 
                   back-positions pointer (aborts file in case of
                   non-match; fairly inefficient).
                   To move \\G back one line, use --backpos '.*\\n'
  --bmax  N        number of previous lines to buffer ($bufferlines)
  --bpmax N        maximum number of bytes to look back ($backposmax)
  --examples       help
  --flock          use perl flock() to exclusively lock a file, skip
                   otherwise; implies -p.

EOF
}

sub examples {
   warn <<EOF;

On grep output formats:

The  supported  grep  formats are  'FILE:NUMBER:CONTENT-OF-LINE\\n'  or
Grep.pm's  modified context format 'FILE:NUMBER: > CONTENT-OF-LINE\\n',
all other lines are silently discarded.


On available variables and ending early:

The  whole file content is availabe in \$_ (original copy in  \$content)
and the current line in \$LINE, with offset and line number in \$POS and
\$LINENO.  You  can modify either one of \$LINE or \$_. The previous  two
lines  are in \$BUFFER. To end changing a file, set \$ERR to 1. To abort
changing it, any true value or string. It is advisable to use my() and
to  stick  to  single-letter  variables  inside  the  perl  scrap  for
&matchsubst.


On paranoia and keeping the line count in sync with grep:

If  you  delete  or  insert lines, you're responsible  to  update  the
variable  \$LINEOFFSET suitably. If you set \$OLD and \$NEW, or \$LINE  is
changed, the script itself will calculate the offset.


On anchoring matches:

Anchoring  is probably most helpful when matching against \$_. You  can
use  /\\G.../g  to  anchor to pos(), and pos() / m/.../gc to  keep  the
position  in case of a failing match. Using \\G does allow at most  one
zero-width  m//g  to succeed. Also note that \\G "forgets chars on  its
left,  thus changing the notion of 'width'. Note that you can also use
the modifier /c to retain pos() in case of a miss.


On links:

We break hardlinks and (\$o_follow) resolve symlinks.


Examples:

The  next example shows both ways of accessing the current line,  then
it  changes  all occurances of 'local' in the line; the  diff  finally
shows the effects of globalization.

   grep -n local /etc/hosts /dev/null | Grep.xchange -V -diff \\
      '/\\G(?=(.*\\n?))/g and warn "SRC: \$1GREP: $LINE"; 
      \$LINE=~s/local/global/g'

Skipping  the  SRC/GREP demo, this examples makes the same  change  by
modifying the file's contents instead. To stay within the line, we use
\\G,  which  is slightly magic as s///g now avoids to advance the  next
match position beyond the end of the previous match.

   grep -n local /etc/hosts /dev/null | \\
   Grep.xchange -V -diff 's/\\G(.*?)local/\$1global/g'

EOF
}

sub setupworkdir {
   my ($dir)=@_;
   mkdir $dir if not -d $dir;
   chmod 0700, $dir;
   return 0 if (stat $dir)[4] != $<;       # danger: ownership mismatch!?
   foreach (<$dir/$logclean>) { # clean old logs
      unlink $_ if time-(stat $_)[9]>$logkeep*86400;
   }
   return 1;
}

sub followlink {
   my($c,$p);
   local($_);
   ($_)=@_;
   if ($o_follow) {
      $p=$_; $c=1;
      $p=~s@[^/]*/?$@@; $p=~s@(^\.|/\.|/+)(?=/)@@g; 
      $p=$ENV{PWD}."/".$p if $p!~m@^/@;
      while(-l $_) {
         return "" if $c++>30; # bailout, depth is getting absurd
         $_=readlink($_);
         $_="$p/$_" if not m@^/@;
         $p=$_;
         $p=~s@[^/]*/?$@@; $p=~s@(^\.|/\.|/+)(?=/)@@g; 
         $p=$ENV{PWD}."/".$p if $p!~m@^/@;
      }   
   }
   return $_;
}
