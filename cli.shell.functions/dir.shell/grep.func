# created     PJ 200907XX jakobi@acm.org
# copyright:  (c) 2009 jakobi@acm.org, GPL v3 or later
# archive:    http://jakobi.github.com/script-archive-doc/

function gr_x { 
   for i in /*FIND* /disk*/*FIND*; do
       case "$i" in
          *.gz)                zcat < "$i"      ;; # or zegrep to reduce piping
          *.bzip|*.bz|*.bzip2) bzcat < "$i"     ;; 
          # - actually we should differentiate between {latin1,utf8} x {nl,\0-terminated}, 
          #   all of which may also be gzipped, etc. 
          #   [\0 currently only used for /FIND during backup; and 
          #    indeed we have wide char probs already in /FIND; 1 for cat, 3 for cat0]
          # - possibly exclude already seen files from symlinks, caching stat[0,1]:
          #   normal stat w/o -l first resolves all links/symlinks:
          #   perl -e 'print join(":",(stat $ARGV[0])[0,1])."\n";'
          #   -> but for speed, fully rewrite in perl
          *)                   if head -c 300 < "$i" | tr -c -d '\0' | grep -a . >/dev/null; then
                                  tr '\0' '\12' < "$i"
                               else 
                                  cat < "$i"
                               fi
                               ;;
       esac
   done | egrep -v -i -e '^/[^/]*/SYSTEM-BACKUPS' -e '^/[^/]*/automated-backup' | Grep.pm -h -i -B "$@" | sort -u
}



# filters

function gr_H { gr_HELP; }
function gr_HELP {
   cat <<EOF 
 gr_* family of filename filters (uniq/unsort implied except gr_S):
 gr_H, gr_HELP
 gr_U, gr_UNIQ   -- uniq but not sort input
 gr_S, gr_STRIP  -- strip ' :: '-comments from input (e.g. ogg tags, etc)
 gr_D, gr_DIR    -- truncate to basedir
 gr_F, gr_FILE   -- existing plain files (implies strip/uniq)
 gr_D0           -- magical truncate to basedir/filename
 gr_DS           -- magical paren removal + ~~-shorten for long filenames
EOF
}
# gr_* family of filters for handling reporting lists of files (changed to uniq/unsort, caches all seen entries)
function gr_F { gr_FILE; }
function gr_FILE { 
   perl -lne 'next if $c{$_}; do{print;$c{$_}++;next} if -f $_; s/ :: +(\S.*|)?$// and do{next if $c{$_};do{print;$c{$_}++;next} if -f $_};'
}
function gr_S { gr_STRIP; }
function gr_STRIP {
   perl -lne 's/ :: +(\S.*|)?$//; print' # no uniq for this
}
function gr_U { gr_UNIQ; }
function gr_UNIQ {
   perl -lne 'print if not $c{$_}++'
}
function gr_D   { gr_DIR; }
function gr_DIR { 
   perl -lne 's@/[^/]*$@@; print if not $c{$_}++' # uniq, but unsorted
   # sed 's@/[^/]*$@@' | sort -u or just in sed (uniq w/o sort): sed 's@/[^/]*$@@'|sed '$!N; /^\(.*\)\n\1$/!P; D'
}
function gr_D0 { gr_DIR0;}
function gr_DIR0 { 
   # shorten to the final dir/filename with a twist:
   # go further left while dir is numbered, i.e. \d* c\d* v\d* 
   perl -lne '"SECURE:OK";BEGIN {s!^(\s)!./$1!,s/^/</,s/$/\0/ for @ARGV}; s@.*?(((/|^)(?!\d|[vc]\d)[^/]+)(/(?=\d|.\d)[^/]+)*/[^/]+)$@...$1@i; print if not $c{$_}++'
}
function gr_DS { gr_DIRSHORTEN;}
function gr_DIRSHORTEN { 
   # shorten by paren+ removal to a single ~~, then if there's still a monstrous name
   # in the path, truncate it in the middle. Use $1 to change 'longness'.
   # tries to allow for the highlighting codes as used on xterm by tput rmso/smso
   # and e.g. grep.p / hlgrep (3-5bytes). Does NOT add ESC when line is ESC-clean.
   N=${1:-60} perl -lne 'BEGIN{s!^(\s)!./$1!,s/^/</,s/$/\0/ for @ARGV; # fix <> mess
                               use POSIX;$n=$ENV{N}||60; 
                               $p=q![^/\(\)\[\]\{\}]!; chomp($se=qx(tput rmso)); $m=floor($n/2)
                              };
      do{ local ($se)=$se;  $se="" if not /x1b/o;
          s@\($p+\)|\[$p+\]|\{$p+]\}[\. -_]?@~~@go; s@(~~[^~/]?)+~~@~~@go; 
          ##  s@/([^/]{2}[^/]{$n,})(?=/|$)@do{$2.substr($$1,0,$n/2)."~~".substr($1,-$n/2)}@ge; 
          #anchor-/    prefix optional glue used to forbid ESC    middle            glue/esc protect     postfix         anchor  
          s@( (?:/|\A) [^/]{$m}  [^/]{0,5}? )   (?<=[^\x1b]{5})   [^/]{2,}   (?<=[^\x1b]{5})   ( [^/]{0,5}?  [^/]{$m} )  (?=/|$)@$1~~$2@gx;
          s@~~@$se~~@go;
      }; print if not $c{$_}++'
}


# vim:filetype=sh
