# created     PJ 200907XX jakobi@acm.org
# copyright:  (c) 2009 jakobi@acm.org, GPL v3 or later
# archive:    http://jakobi.github.com/script-archive-doc/

function gr_x { 
   for i in /*FIND* /disk*/*FIND*; do
       case "$i" in
          *.gz)                zcat < "$i"      ;; # or zegrep to reduce piping
          *.bzip|*.bz|*.bzip2) bzcat < "$i"     ;; 
          # - actually we should differentiate between {latin1,utf8} x {nl,\0-terminated}, 
          #   all of which may also be gzipped, etc. 
          #   [\0 currently only used for /FIND during backup; and 
          #    indeed we have wide char probs already in /FIND; 1 for cat, 3 for cat0]
          # - possibly exclude already seen files from symlinks, caching stat[0,1]:
          #   normal stat w/o -l first resolves all links/symlinks:
          #   perl -e 'print join(":",(stat $ARGV[0])[0,1])."\n";'
          #   -> but for speed, fully rewrite in perl
          *)                   if head -c 300 < "$i" | tr -c -d '\0' | grep -a . >/dev/null; then
                                  tr '\0' '\12' < "$i"
                               else 
                                  cat < "$i"
                               fi
                               ;;
       esac
   done | egrep -v -i -e '^/[^/]*/SYSTEM-BACKUPS' -e '^/[^/]*/automated-backup' | Grep.pm -h -i -B "$@" | sort -u
}



# filters

function gr_H { gr_HELP; }
function gr_HELP {
   cat <<EOF 
 # gr_* family of filename filters (all retain original ordering):
 gr_H, gr_HELP
 gr_U, gr_UNIQ    -- uniq
 gr_S, gr_STRIP   -- strip ' :: '-comments from input (e.g. '<filename> :: <ogg tags>+')
 gr_D, gr_BASEDIR -- truncate to basedir (implies uniq)

 # filter accesses fs (implies stat/strip/uniq; allows for files containing ' :: '):
 gr_STRIP0        -- only existing in fs (strict superset of gr_STAT[FD])
 gr_STATF         -- only plain files 
 gr_STATD         -- only existing dir/symlink to existing dir
 gr_BASEDIR0      -- truncate plain files to basedir, but keep dirs as is

 # reporting only (implies uniq; output is no longer a list of filenames):
 # BUG: should honor COLUMNS to specify what to cut
 gr_SHORT         -- magical truncate to basedir/filename
 gr_SHORT0        -- magical paren removal + ~~-shorten for long filenames

EOF
}
# gr_* family of filters for handling reporting lists of files (changed to uniq/unsort, caches all seen entries)
function gr_STRIP0 { 
   perl -lne 'next if $c{$_}; do{print;$c{$_}++;next} if -e $_; s/ :: +(\S.*|)?$// and do{next if $c{$_};do{print;$c{$_}++;next} if -e $_};'
}
function gr_STATF { 
   perl -lne 'next if $c{$_}; do{print;$c{$_}++;next} if -f $_; s/ :: +(\S.*|)?$// and do{next if $c{$_};do{print;$c{$_}++;next} if -f $_};'
}
function gr_STATD { 
   perl -lne 'next if $c{$_}; do{print;$c{$_}++;next} if -d $_; s/ :: +(\S.*|)?$// and do{next if $c{$_};do{print;$c{$_}++;next} if -d $_};'
}
function gr_S { gr_STRIP; }
function gr_STRIP {
   perl -lne 's/ :: +(\S.*|)?$//; print' # no uniq for this
}
function gr_U { gr_UNIQ; }
function gr_UNIQ {
   perl -lne 'print if not $c{$_}++'
}
function gr_D { gr_BASEDIR; }
function gr_BASEDIR { # note that this can easily strip the matched keyword from the filename
   perl -lne 's@/[^/]*$@@ if not m!/(MNG|LNK)\.[^/]+$|/[^/]*\.lnk!; print if not $c{$_}++' # uniq, but unsorted, don't strip .lnk (hopefully a symlink)
   # sed 's@/[^/]*$@@' | sort -u or just in sed (uniq w/o sort): sed 's@/[^/]*$@@'|sed '$!N; /^\(.*\)\n\1$/!P; D'
}
function gr_BASEDIR0 { #
   perl -lne 'next if $c{$_}; do{print;$c{$_}++;next} if -d $_; 
              s/ :: +(\S.*|)?$// if not -e _; 
              next if $c{$_}; do{print;$c{$_}++;next} if -d $_; 
              s@/[^/]*$@@ if not m!/(MNG|LNK)\.[^/]+$|/[^/]*\.lnk!; print if not $c{$_}++'
}
function gr_SHORT { 
   # shorten to the final dir/filename with a twist:
   # go further left while dir is numbered, i.e. \d* c\d* v\d* 
   perl -lne '"SECURE:OK";BEGIN {s!^(\s)!./$1!,s/^/</,s/$/\0/ for @ARGV}; s@.*?(((/|^)(?!\d|[vc]\d)[^/]+)(/(?=\d|.\d)[^/]+)*/[^/]+)$@...$1@i; print if not $c{$_}++'
}
function gr_SHORT0 { 
   # shorten by paren+ removal to a single ~~, then if there's still a monstrous name
   # in the path, truncate it in the middle. Use $1 to change 'longness'.
   # tries to allow for the highlighting codes as used on xterm by tput rmso/smso
   # and e.g. grep.p / hlgrep (3-5bytes). Does NOT add ESC when line is ESC-clean.
   N=${1:-60} perl -lne 'BEGIN{s!^(\s)!./$1!,s/^/</,s/$/\0/ for @ARGV; # fix <> mess
                               use POSIX;$n=$ENV{N}||60; 
                               $p=q![^/\(\)\[\]\{\}]!; chomp($se=qx(tput rmso)); $m=floor($n/2)
                              };
      do{ local ($se)=$se;  $se="" if not /x1b/o;
          s@\($p+\)|\[$p+\]|\{$p+]\}[\. -_]?@~~@go; s@(~~[^~/]?)+~~@~~@go; 
          ##  s@/([^/]{2}[^/]{$n,})(?=/|$)@do{$2.substr($$1,0,$n/2)."~~".substr($1,-$n/2)}@ge; 
          #anchor-/    prefix optional glue used to forbid ESC    middle            glue/esc protect     postfix         anchor  
          s@( (?:/|\A) [^/]{$m}  [^/]{0,5}? )   (?<=[^\x1b]{5})   [^/]{2,}   (?<=[^\x1b]{5})   ( [^/]{0,5}?  [^/]{$m} )  (?=/|$)@$1~~$2@gx;
          s@~~@$se~~@go;
      }; print if not $c{$_}++'
}


# vim:filetype=sh
