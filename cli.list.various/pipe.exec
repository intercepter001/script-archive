#!/usr/bin/perl

my $version="0.1.1";
# created     PJ 200908XX jakobi@acm.org
# last change PJ 201002   ignore heading in testing for data
# copyright:  (c) 2009 jakobi@acm.org, GPL v3 or later
# archive:    http://jakobi.github.com/script-archive-doc/

# for use in pipes / conditional execution if data available
# type 1) $0 [--ignore-header] command...  -- slurp stdin AND pipe-execute command (w/o intervening shell)
# type 2) $0 [--ignore-header]             -- cat   stdin  OR false (test data in pipe)
#
# usage examples:
# - grep foo LOG |   pipe.exec         mutt -s "ALERT - log contains matching terms" $LOGNAME  # type 1 - mail on match
# - grep foo LOG | { pipe.exec || echo "no matches"; } | mutt -s "daily log summary" $LOGNAME  # type 2 - mail always
# - ... | (echo "# please check these lines"; echo; cat - ) | pipe.exec --ignore-header gvim - # type 1 - display data in editor if any

undef $/; 
$_=<main::STDIN>;
$no_data=1 if $_ eq "";

while(@ARGV) {
   # --header: during testing, ignore initial white-space/#-comments
   $ARGV[0]=~/^-i$|^-h$|^-?-(ignore[-_])?head(ers?)?/ and do{
      m! \A (?: \s*\z | (?: (?:[\t ]* (?:\#.*)?) [\r\n]+ )* ) ([\S\s]?) !x and $no_data=("" eq $1); 
      shift; next
   };
   last;
}

                                   #  type / input     - output               - return code
                                   # -----------------   --------------------   -----------
if      (not @ARGV and $no_data) { # 2 - test: no data - none                 - false
   exit 1;
} elsif (not @ARGV) {              # 2 - test: data    - print data on stdout - true
   print $_;
   exit 0;
} elsif ($no_data) {               # 1 -  cmd: no data - none                 - true
   exit 0;
} else {                           # 1 -  cmd: data    - pipe data to cmd     - cmd rc
   open(FH,"|-",@ARGV) and print FH $_; exit $?>>8 if $?;
   close FH;                            exit $?>>8 if $?;
   exit 0;
}
