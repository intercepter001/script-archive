#!/usr/bin/perl

# I'm really unhappy about busybox's missing -c option
# for netstat on android. So here's something to cope
# with this situation and still permit to 'roughly'
# track ongoing connections:

# $0 [-v] [-i] [-e pattern] ... [--] [command]
# 
# run command repeatedly and report changes 
# (consider e.g. $0 -e FILTER -- netstat -pWn | hlgrep PATTERN > log
#  instead of depending on watch netstat or a mere netstat -c)

my $version="0.1";
# 20120128 PJ        initial version jakobi@acm.org
#
# (c) 2012 PJ, placed under GPL v3
# archive:   http://jakobi.github.com/script-archive-doc/


# NOTES:


# BUGS:
# - diff mode is a bit cruel on the eyes.
# - tmpfile handling in diff mode has a race



use strict;
use vars;
use warnings;

# use modifyable, not yet exported as a cli option
my $o_sort=0;       # set to 1 to always sort line mode output

#
my $o_sleep=1;      
my $o_count=-1;
my $o_negate=0;
my $o_pattern=".";
my $o_highlite="";
my $o_igncase="";
my $o_verbose=0;   
my $o_diff=undef;
my $o_mangle="";

#
my $errcnt_max=10;  # max ammount of transient failures of command before abort
my ($errcnt,$errcnttotal)=(0,0);
my %output=();      # collect current state of command output
my ($SO,$SE,$evaloutput,$evalprint,$rc,@oldoutput);
my (@e,@H,$vo);
my ($t,$ts,@l);
my (@diffcmd, @diff);
my $tmpfile="/tmp/watchdelta.$$";
my $tmpfile0=$tmpfile.".old";

$|=1;



while($_=shift @ARGV) {
   /^-e$/         and do { push @e, shift;    next};
   /^-H$/         and do { push @H, shift;    next};
   /^-M$/         and do { $o_mangle=shift;   next};
   /^-v$/         and do { $o_negate="!";     next};
   /^-d$/         and do { $o_diff=shift;     next};
   /^-i$/         and do { $o_igncase="i";    next};
   /^-s$/         and do { $o_sleep=shift;    next};
   /^-n$/         and do { $o_count=shift;    next};
   
   /^-?-verbose$/ and do { $o_verbose++;      next};
   /^-?-netstat$/ and do { unshift @ARGV, qw/-v -e STREAM|DGRAM/;
                           push @ARGV, qw/-- netstat -npW/ if not grep {/--/}@ARGV; next};

   /^-?-help$/    and do { &usage;            exit};
   /^-?-$/        and do {                    last};
   unshift @ARGV, $_; last;
}
die "!! ERROR: no command specified\n" if not @ARGV;
open(ERR, ">&", \*STDERR);
$o_pattern= "(".join(")|(",@e).")" if @e; @e=undef;
$o_highlite="(".join(")|(",@H).")" if @H; @H=undef;
$evaloutput="\@output=grep{$o_negate/\$o_pattern/o$o_igncase}\@output\n";
if ($o_highlite){
   ($SO, $SE)=(`tput smso 2>/dev/null`,`tput rmso 2>/dev/null`);
   ($SO, $SE)=("\x1b[0;33m","\x1b[0m") if not $SO; 
   $evalprint="\@print=grep{s/\$o_highlite/\$SO\$1\$SE/o$o_igncase;1}\@print\n";
}


my $start=$o_count;
while($o_count--) {
   $t=time; 
   @l=localtime; 
   $ts=sprintf "%04d%02d%02d-%02d%02d%02d",$l[5]+1900,$l[4]+1,@l[3,2,1,0];
   do{print ERR "!! ERROR: too many command errors in sequence\n"; exit 42} if $errcnt_max < $errcnt;

   if (defined $o_diff) {
      &diffmode;
   } else {
      &linemode;
   }
   
   # first loop - special command sanity handling (also close STDERR now to unclutter display)
   if ($o_count+1 == $start) {
      close STDERR;
      do{print ERR "!! ERROR: errors occured during first execution - aborting ($rc / $errcnt)\n"; exit 42} if $rc or $errcnt;

      # print an extra line feed to separate initial run from delta
      print "\n";  
   }

   sleep $o_sleep if $o_sleep; 
}
exit 1 if $errcnttotal;
exit 0;

# ---------------------------------------------------------------------------------------------

sub usage{
   print <<EOF
watchdelta [OPTIONS]                 -- command ...
watchdelta [OPTIONS] -D "DIFFOPTION" -- command ...

Runs command repeatedly and reports all changed lines with timestamps.
The  second  invocation runs the host's diff on  subsequent  command's
output instead of using the builtin tracking of changed lines.


Options:
 -i         ignore case for -H and -e options
 -n N       limit to N iterations                                 ($o_count)
 -s S       sleep S seconds between iterations                     ($o_sleep)
 -v         invert matching for -e option
 --verbose

Filtering options (before computing delta):
 -e RE      regex to select lines                (honors -i, -v, ORed)
 -M PE      mangle each line first using an arbitrary
            perl expression PE                         (ignores -v/-i)

Reporting options:
 -d DOPT    instead of tracking line changes, just diff command output
            using system diff with options DOPT (DOPT: "-wc", "", ...)
 -H RE      regex to highlight                       (honors -i, ORed)

Laziness options:
 --netstat  prepend -v -e 'STREAM|DGRAM' and optionally append 
            -- netstat -npW)


Notes:
 - instead of coping with netstat -c or  watch netstat, you  can get a
   a more useful output by running watch_delta --netstat | tee -a log; 
   aka  watch_delta -v -i 'STREAM|DGRAM' -- netstat -npW | tee -a log.
   Note that neither  netstat -c  nore above command are able to catch 
   short term connections; this might require inotify or worse...
EOF
}


# run system diff on current and previous output,
# timestamp the results with a prefixed with +/- 
# from the relevant diff line
sub diffmode {
   my(@print,@output,@newoutput,@deloutput);
   open(FH, "-|", @ARGV) or do{$errcnt++; print "!  ERROR during attempt to run command\n"; close(FH); return};
   @output=<FH>;
   $errcnt++ if not @output;
   close(FH) and do{$errcnttotal+=$errcnt; @output and $errcnt=0; 1} or $errcnt++;
   $rc=$?>>8;
   return if $errcnt;

   do{for(@output){eval $o_mangle}} if $o_mangle;
   eval $evaloutput;

   unlink $tmpfile0; open(FH, ">", $tmpfile0); print FH @oldoutput; close FH;
   unlink $tmpfile;  open(FH, ">", $tmpfile);  print FH @output; close FH;

   open(FH, "-|", "diff $o_diff $tmpfile0 $tmpfile");
   @print=<FH>;
   close(FH); 
   $rc=$?>>8;
   unlink $tmpfile, $tmpfile0;
   do{ print ERR "!  ERROR: cannot diff\n"; $errcnt++} if $rc>1;
   $rc=0;

   # skip diff -c header
   do{shift @print} while $print[0]=~/^(\*\*\*|---) \D|^[\*]{7,}/o;

   if (@print) {
      # print "\n$ts\n" if @print; 
      my($c,$d);
      @print=grep{s/^(.)/do{$d=$c=$1; $c=" "if m!^.\S!;"$c $ts $d"}/e; ;1}@print;

      eval $evalprint if $o_highlite;
      print @print;
      print "\n";
   }
   @oldoutput=@output;
}


# report changed lines with a +/- prefix
sub linemode { 
   my(@print,@output,@newoutput,@deloutput);
   open(FH, "-|", @ARGV) or do{$errcnt++; print "!  ERROR during attempt to run command\n"; close(FH); return};
   @output=<FH>;
   $errcnt++ if not @output;
   close(FH) and do{$errcnttotal+=$errcnt; @output and $errcnt=0; 1} or $errcnt++;
   $rc=$?>>8;
   return if $errcnt;

   @output=grep{/./}@output;
   do{for(@output){eval $o_mangle}} if $o_mangle;
   eval $evaloutput;

   for(@output){
      if (not $output{$_}) {
         push @newoutput, $_;
      }
      $output{$_}=$t;
   };
   for(keys %output){
      if ($t != $output{$_}) {
         delete $output{$_};
         push @deloutput, $_;
      }
   }

   if (@deloutput or @newoutput) {
      do{print "\n"; $vo=0} if $o_verbose and $vo;
      push @print, grep{s/^/- $ts: /}sort @deloutput; # ok 
      # for the initial run, do NOT sort
      push @print, grep{s/^/+ $ts: /}sort @newoutput if $start != $o_count+1 or $o_sort;
      push @print, grep{s/^/+ $ts: /}     @newoutput if $start == $o_count+1 and not $o_sort; 
      eval $evalprint if $o_highlite;
      print @print;
   } else {
      do{print "."; $vo++;} if $o_verbose;
   }
}
